{"ast":null,"code":"import _asyncToGenerator from \"/Users/rafaaseddik/Documents/Personal/projects/Clonium-Web/frontend/clonium-web/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { environment } from '../../../environments/environment';\nimport * as io from 'socket.io-client';\nimport { Player } from '../../shared/models/player.model';\nimport { Subject } from 'rxjs';\nimport { Message } from '../../shared/models/message.model';\nimport { GameState } from '../../shared/models/game-state.model';\nimport { nextGameState } from '../../shared/utils/utilFunctions';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\n/**\n * @description\n * This service is responsible for synchronizing and configuring an online game room.\n * Communication with the backend server is done using an HTTP API to create or to join a game for the first time (mainly used to get a roomID)\n * And a socket connection to communicate with the other room's players and to synchronise the game state with the other players.\n *\n * @author\n * Rafaa Seddik\n */\nexport let RoomService = /*#__PURE__*/(() => {\n  class RoomService {\n    /**\n     * The socket event handlers are declared in the constructor\n     */\n    constructor(http) {\n      this.http = http;\n      /**\n       * The current player number\n       */\n      this.currentPlayerNumber = 0;\n      /**\n       * These RxJS subject are used to notify the board.component if a player has joined/unjoined the current room\n       * these subjects\n       *    - emit 'true' if the corresponding player joined the room\n       *    - emit 'false' if the corresponding player unjoined the room\n       */\n      this.playerOneJoined = new Subject();\n      this.playerTwoJoined = new Subject();\n      this.playerThreeJoined = new Subject();\n      this.playerFourJoined = new Subject();\n      /**\n       * This RxJS subject is used to notify the board.component if another player has made a move\n       * a move is characterised by :\n       *    - the player : who made the mode\n       *    - the coordinates of the clicked cell (x,y)\n       */\n      this.move = new Subject();\n      /**\n       * This RxJS subject is used to notify the board.component if another player sent a message\n       */\n      this.receiveMessage = new Subject();\n      /**\n       * Create the socket connection with the backend server\n       */\n      this.socket = io(environment.API_URL);\n      /**\n       * These events are used to handle the players joining/unjoining the current room\n       * TODO : Group these events in one unique event\n       */\n      this.socket.on('first_player_joined', toggle => {\n        this.playerOneJoined.next(toggle);\n      });\n      this.socket.on('second_player_joined', toggle => {\n        this.playerTwoJoined.next(toggle);\n      });\n      this.socket.on('third_player_joined', toggle => {\n        this.playerThreeJoined.next(toggle);\n      });\n      this.socket.on('fourth_player_joined', toggle => {\n        this.playerFourJoined.next(toggle);\n      });\n      /**\n       * The event is used to be notified when another player has made a move\n       */\n      this.socket.on('move', (player, x, y) => {\n        this.move.next({\n          player,\n          x,\n          y\n        });\n      });\n      /**\n       * When a player joins/unjoins the room, the backend server pings all the players in the room to check who's connected and who's not\n       * When a player gets a ping event, it will emit a 'ping-response' event\n       */\n      this.socket.on('ping', () => {\n        this.socket.emit('ping-response', this.roomID, this.currentPlayerNumber);\n      });\n      /**\n       * This is the event handler for when a player send a message in the current room\n       */\n      this.socket.on('receive-message', (message, player) => {\n        this.receiveMessage.next(new Message(player, message));\n      });\n    }\n    /**\n     * @description\n     * This method is used to contact the backend server to request the creation of a new online room\n     * The backend server will respond with the newly created roomID : the room's unique identifier\n     *\n     * After joining the room, the persistSession() method will be called\n     * @author\n     * Rafaa Seddik\n     *\n     * @param mapName\n     * The map template name, the game currently supports 3 templates : rect1, rect2, rect3\n     * @param playersNumber\n     * The number of player in the board, the game supports from 2 up to 4 players\n     * @param side\n     * The game is a square matrix, side is the matrix dimension (example : if side=3 => the board is a 3x3 matrix)\n     *\n     * @returns ASYNC\n     * The newly created board\n     */\n    createRoom(mapName, playersNumber, side) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        return new Promise((resolve, reject) => {\n          let body = {\n            mapName: mapName,\n            playersNumber: playersNumber,\n            side: side\n          };\n          _this.http.post(environment.API_URL + 'room/create', body).subscribe(responseJSON => {\n            if (responseJSON['success']) {\n              _this.roomID = responseJSON['roomID'];\n              /**\n               * Emit a 'create-room' event with the newly created roomID to subscribe the current socket in the the room Socket Namespace\n               */\n              _this.socket.emit('create-room', _this.roomID);\n              _this.currentPlayerNumber = 1;\n              _this.persistSession();\n              resolve(responseJSON['board']);\n            } else {\n              reject();\n            }\n          }, error => {\n            reject(error);\n          });\n        });\n      })();\n    }\n    /**\n     * @description\n     * This webservice requests the backend to have access to an online room by its roomID,\n     * if there is still an available place in the room, the backend will respond with :\n     *    - The Map Template Name : the game currently supports 3 templates : rect1, rect2, rect3\n     *    - The Map number of players\n     *    - The Map side: The game is a square matrix, side is the matrix dimension (example : if side=3 => the board is a 3x3 matrix)\n     *    - The player number given to the current player\n     *\n     * After joining the room, the persistSession() method will be called\n     *\n     * @author\n     * Rafaa Seddik\n     *\n     * @param roomID\n     * The room id to join\n        * @returns ASYNC\n     *    - mapName: the game currently supports 3 templates : rect1, rect2, rect3\n     *    - playersNumber: The number of player in the board, the game supports from 2 up to 4 players\n     *    - currentPlayer: The current player number\n     *    - side: The game is a square matrix, side is the matrix dimension (example : if side=3 => the board is a 3x3 matrix)\n     *\n     */\n    joinRoom(roomID) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        return new Promise((resolve, reject) => {\n          const body = {\n            roomID: roomID\n          };\n          _this2.http.post(environment.API_URL + 'room/join', body).subscribe(responseJSON => {\n            if (responseJSON['success']) {\n              /**\n               * Emit a 'join-room' event with the roomID to subscribe the current socket in the the room Socket Namespace\n               */\n              _this2.socket.emit('join-room', roomID, responseJSON['board']['currentPlayerNumber']);\n              _this2.currentPlayerNumber = responseJSON['board']['currentPlayerNumber'];\n              _this2.roomID = roomID;\n              _this2.persistSession();\n              let currentPlayer;\n              switch (responseJSON['board']['currentPlayerNumber']) {\n                case 1:\n                  currentPlayer = Player.PLAYER_1;\n                  break;\n                case 2:\n                  currentPlayer = Player.PLAYER_2;\n                  break;\n                case 3:\n                  currentPlayer = Player.PLAYER_3;\n                  break;\n                case 4:\n                  currentPlayer = Player.PLAYER_4;\n                  break;\n                default:\n                  currentPlayer = Player.PLAYER_2;\n              }\n              resolve({\n                mapName: responseJSON['board'].room.board,\n                playersNumber: responseJSON['board'].room.playersNumber,\n                currentPlayer: currentPlayer,\n                side: responseJSON['board'].room.side\n              });\n            } else {\n              reject();\n            }\n          }, error => {\n            reject(error);\n          });\n        });\n      })();\n    }\n    /**\n     * @description\n     * This method requests the socket engine to subscribe the current socket in the already persisted roomID namespace to have access the online room\n     * The current socket will send only the persisted SocketID\n     * if the socket engine verifies if the socketID was really subscribed in the roomID namespace, it will callback with :\n     *    - roomIDWS : The roomID where the persisted Socket was subscribed to\n     *    - playerNumber : The player number assigned to the socket\n     *    - mapName : The Map Template Name (the game currently supports 3 templates : rect1, rect2, rect3)\n     *    - playersNumber : The Map number of players\n     *    - side : The game is a square matrix, side is the matrix dimension (example : if side=3 => the board is a 3x3 matrix)\n     *    - serialBoard : Contains a serialized version for the board state (the players' cells positions)\n     *    - lastPlayed : The last player who played\n     *\n     * After joining the room, the persistSession() method will be called\n     *\n     * TODO : Synchronize lost players when rejoining the room\n     * @author\n     * Rafaa Seddik\n     *\n     * @returns ASYNC\n     *    - mapName: the game currently supports 3 templates : rect1, rect2, rect3\n     *    - playersNumber: The number of player in the board, the game supports from 2 up to 4 players\n     *    - currentPlayer: The current player number\n     *    - side: The game is a square matrix, side is the matrix dimension (example : if side=3 => the board is a 3x3 matrix)\n     *    - serialBoard: Contains a serialized version for the board state (the players' cells positions)\n     *    - currentState: When rejoining an old game, this parameter contains the current game state (who's turn is it)\n     *\n     */\n    rejoinRoom() {\n      return new Promise((resolve, reject) => {\n        /**\n         * Get the persisted session\n         */\n        let {\n          socketID,\n          roomID\n        } = JSON.parse(localStorage.getItem('clonium-session'));\n        /**\n         * Send the persisted socket ID\n         */\n        this.socket.emit('rejoin-room', socketID, (roomIDWS, playerNumber, mapName, playersNumber, side, serialBoard, lastPlayed) => {\n          /**\n           * Verify if the persisted roomID is equal to the roomID sent by the socket engine\n           */\n          if (roomIDWS == roomID) {\n            /**\n             * Emit a 'join-room' event with the roomID to subscribe the current socket in the the room Socket Namespace\n             */\n            this.socket.emit('join-room', roomID, playerNumber);\n            this.roomID = roomID;\n            this.persistSession();\n            let currentPlayer;\n            this.currentPlayerNumber = playerNumber;\n            /**\n             * parse the current player number\n             */\n            switch (playerNumber) {\n              case 1:\n                currentPlayer = Player.PLAYER_1;\n                break;\n              case 2:\n                currentPlayer = Player.PLAYER_2;\n                break;\n              case 3:\n                currentPlayer = Player.PLAYER_3;\n                break;\n              case 4:\n                currentPlayer = Player.PLAYER_4;\n                break;\n              default:\n                currentPlayer = Player.PLAYER_2;\n            }\n            /**\n             * Get the current GameState from the lastPlayed value\n             */\n            let currentState;\n            if (lastPlayed == 0) {\n              currentState = GameState.PLAYER_1;\n            } else {\n              let lastPlayingPlayer;\n              switch (lastPlayed) {\n                case 1:\n                  lastPlayingPlayer = Player.PLAYER_1;\n                  break;\n                case 2:\n                  lastPlayingPlayer = Player.PLAYER_2;\n                  break;\n                case 3:\n                  lastPlayingPlayer = Player.PLAYER_3;\n                  break;\n                case 4:\n                  lastPlayingPlayer = Player.PLAYER_4;\n                  break;\n                default:\n                  lastPlayingPlayer = Player.PLAYER_2;\n              }\n              currentState = nextGameState(lastPlayingPlayer, playersNumber);\n            }\n            resolve({\n              mapName,\n              playersNumber,\n              currentPlayer,\n              side,\n              serialBoard,\n              currentState\n            });\n          } else {\n            reject();\n          }\n        });\n      });\n    }\n    /**\n     * @deprecated\n     * TODO : Remove from codebase\n     *\n     * @description\n     * Gets the number of connected players in a room\n     *\n     * @author\n     * Rafaa Seddik\n     *\n     * @param roomID\n     */\n    getConnectedPlayers(roomID) {\n      return new Promise((resolve, reject) => {\n        const body = {\n          roomID: roomID\n        };\n        this.http.post(environment.API_URL + 'room/getConnectedPlayers', body).subscribe(responseJSON => {\n          resolve(responseJSON['result']);\n        }, error => {\n          reject();\n        });\n      });\n    }\n    /**\n     * @description\n     * Send a message to the room\n     *\n     * @author\n     * Rafaa Seddik\n     *\n     * @param message\n     * The message content\n     * @param player\n     * The sender player number\n     */\n    sendMessage(message, player) {\n      this.socket.emit('send-msg', this.roomID, message, player);\n    }\n    /**\n     * @description\n     * Broadcast the last played move in the room namespace to synchronize with the other players\n     *\n     * @author\n     * Rafaa Seddik\n     *\n     * @param player\n     * the player's number\n     * @param cell\n     * the played cell object\n     */\n    emitMove(player, cell) {\n      return new Promise((resolve, reject) => {\n        let playerNumber = 1;\n        switch (player) {\n          case Player.PLAYER_1:\n            playerNumber = 1;\n            break;\n          case Player.PLAYER_2:\n            playerNumber = 2;\n            break;\n          case Player.PLAYER_3:\n            playerNumber = 3;\n            break;\n          case Player.PLAYER_4:\n            playerNumber = 4;\n            break;\n        }\n        if (this.roomID) {\n          this.socket.emit('move', this.roomID, playerNumber, cell.x, cell.y, () => {\n            console.log('callback');\n            resolve(true);\n          });\n        }\n      });\n    }\n    /**\n     * @description\n     *\n     * @author\n     * Rafaa Seddik\n     * @param serialBoard\n     * @param lastPlayed\n     */\n    sendSerialBoard(serialBoard, lastPlayed) {\n      this.socket.emit('synchronize-board', this.roomID, serialBoard, lastPlayed);\n    }\n    /**\n     * @description\n     * Stores the current SocketID and the current roomID in the browser's localstorage\n     *\n     * @author\n     * Rafaa Seddik\n     */\n    persistSession() {\n      localStorage.setItem('clonium-session', JSON.stringify({\n        socketID: this.socket.id,\n        roomID: this.roomID\n      }));\n    }\n    /**\n     * @description\n     * Deletes the session data from the browser's localstorage\n     *\n     * @author\n     * Rafaa Seddik\n     */\n    removeSession() {\n      localStorage.removeItem('clonium-session');\n    }\n    /**\n     * @description\n     * Checks if the is a stored session in the browser's localstorage\n     *\n     * @author\n     * Rafaa Seddik\n     */\n    getStoredSession() {\n      return localStorage.getItem('clonium-session') != undefined;\n    }\n    static #_ = this.ɵfac = function RoomService_Factory(t) {\n      return new (t || RoomService)(i0.ɵɵinject(i1.HttpClient));\n    };\n    static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: RoomService,\n      factory: RoomService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return RoomService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}