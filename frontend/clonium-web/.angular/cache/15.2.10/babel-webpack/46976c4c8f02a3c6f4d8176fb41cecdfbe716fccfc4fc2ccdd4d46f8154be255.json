{"ast":null,"code":"import { Cell } from './cell.model';\nimport { GameState } from './game-state.model';\nimport { Player } from './player.model';\nimport * as _ from 'lodash';\n/**\n * @description\n * Stores the board data and implements the game-play algorithms\n * @author\n * Rafaa Seddik\n */\nexport class Board {\n  constructor(width, height, playableCells, playersNumber = 2) {\n    // Stores the the players who reachs 0 as score\n    this.lostPlayers = new Set();\n    this.width = width;\n    this.height = height;\n    this.playableCells = playableCells;\n    // initialise playedCells from playableCells Matrix\n    this.playedCells = this.playableCells.map((row, y) => row.map((cell, x) => cell ? Cell.EmptyCell(x, y) : Cell.UnplayableCell(x, y)));\n    this.playersNumber = playersNumber;\n    this.presentPlayers = 1;\n    this.currentState = GameState.PLAYER_1;\n  }\n  /**\n   * @description\n   * Gets a cells by its coordinates\n   *\n   * @author\n   * Rafaa Seddik\n   *\n   * @param x\n   * @param y\n   */\n  getCell(x, y) {\n    return this.playedCells[y][x];\n  }\n  /**\n   * @description\n   * Gets the neighboring cells\n   * the cell in top, bottom, left, and right (if they exist)\n   *\n   * @author\n   * Rafaa Seddik\n   *\n   * @param cell\n   */\n  getCellNeighbors(cell) {\n    const x = cell.x;\n    const y = cell.y;\n    const result = [];\n    if (x - 1 >= 0 && this.playableCells[y][x - 1]) {\n      result.push(this.playedCells[y][x - 1]);\n    }\n    if (y - 1 >= 0 && this.playableCells[y - 1][x]) {\n      result.push(this.playedCells[y - 1][x]);\n    }\n    if (x + 1 < this.width && this.playableCells[y][x + 1]) {\n      result.push(this.playedCells[y][x + 1]);\n    }\n    if (y + 1 < this.height && this.playableCells[y + 1][x]) {\n      result.push(this.playedCells[y + 1][x]);\n    }\n    return result;\n  }\n  /**\n   * @description\n   * Returns if the given coordinates are of a valid playable cell\n   *\n   * @author\n   * Rafaa Seddik\n   *\n   * @param x\n   * @param y\n   */\n  canPlay(x, y) {\n    return x >= 0 && y >= 0 && x < this.width && y < this.height && this.playableCells[y][x];\n  }\n  /**\n   * @description\n   * Sets a playable cell new Cell.model object\n   *\n   * @author\n   * Rafaa Seddik\n   *\n   * @param x\n   * @param y\n   * @param cell\n   */\n  setCell(x, y, cell) {\n    this.playedCells[y][x] = cell;\n  }\n  /**\n   * @description\n   * Serializes the playableCells Array to string\n   * @author\n   * Rafaa Seddik\n   */\n  serialize() {\n    return JSON.stringify(_.flatten(this.playedCells).filter(cell => cell.player === Player.PLAYER_1 || cell.player === Player.PLAYER_2 || cell.player === Player.PLAYER_3 || cell.player === Player.PLAYER_4));\n  }\n  /**\n   * @description\n   * Deserialize the playableCells from a string\n   *\n   * @author\n   * Rafaa Seddik\n   *\n   * @param serialBoard\n   */\n  deserialize(serialBoard) {\n    let rawCellsObject = JSON.parse(serialBoard);\n    rawCellsObject.forEach(rawCell => {\n      this.setCell(rawCell.x, rawCell.y, new Cell(rawCell.x, rawCell.y, rawCell.player, rawCell.value));\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}